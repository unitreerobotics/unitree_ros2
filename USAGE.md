# Usage

## State acquisition

### 1. Sportmode state

The sportmode state message includes position, velocity, foot position, and
other motion state information. To access it, subscribe to the `/sportmodestate` 
or the `/lf/sportmodestate` topic, where "lf" indicates low frequency.

The .msg file is defined as:

```C++
TimeSpec        stamp       // time stamp
uint32          error_code  // error code
IMUState        imu_state   // imu state
uint8           mode        // sportmode
/*
Sportmode
0.  idle, default stand
1.  balance stand
2.  pose
3.  locomotion
4.  reserve
5.  lie sown
6.  joint lock
7.  damping
8.  recovery stand
9.  reserve
10. sit
11. front flip
12. front jump
13. front pounce
*/
float32         progress    // is a dance action being executed?：0. dance false; 1. dance true
uint8           gait_type   // gait type
/*
Gait type
0.  idle  
1.  trot  
2.  run  
3.  climb up stairs  
4.  climb down stairs  
9.  adjust
*/
float32         foot_raise_height 
float32[3]      position 
float32         body_height
float32[3]      velocity 
float32         yaw_speed
float32[4]      range_obstacle
int16[4]        foot_force 
float32[12]     foot_position_body  // foot positions in body frame
float32[12]     foot_speed_body     // foot velocities in body frame
```

For more details, see https://support.unitree.com/home/en/developer/sports_services

To run a complete example:

```bash
./install/unitree_ros2_example/bin/read_motion_state
```

### 2. Low-level state

The low-level state message includes motors states, power information, and
other low-level information. The low-level state can be obtained by
subscribing to the `/lowstate` or the `/lf/lowstate` topic.

The .msg file is defined as:

```C++
uint8[2]        head
uint8           level_flag
uint8           frame_reserve
uint32[2]       sn
uint32[2]       version
uint16          bandwidth
IMUState        imu_state           // imu state
MotorState[20]  motor_state         // motor state
BmsState        bms_state
int16[4]        foot_force 
int16[4]        foot_force_est
uint32          tick
uint8[40]       wireless_remote
uint8           bit_flag
float32         adc_reel
int8            temperature_ntc1
int8            temperature_ntc2
float32         power_v 
float32         power_a 
uint16[4]       fan_frequency 
uint32          reserve
uint32          crc
```

where the MotorState struct is defined as:

```C++
uint8           mode                // mode, 0x01 for control
float32         q                   // joint angle
float32         dq                  // joint velocity
float32         ddq                 // joint acceleration
float32         tau_est             // estimated torque
float32         q_raw               // raw data of q
float32         dq_raw              // raw data of dq
float32         ddq_raw             // raw data of dq
int8            temperature 
uint32          lost
uint32[2]       reserve
```

For more details, see https://support.unitree.com/home/en/developer/Basic_services

To run a complete example:

```bash
./install/unitree_ros2_example/bin/read_low_state
```

Complete examples is in example/src/read_low_state.cpp. 

### 3. Wireless controller

The wireless controller state can be obtained by subscribing to the 
`/wirelesscontroller` topic. You can directly write a messsage to the topic to
control the robot as if pressing the robot's own wireless controller.

The .msg file is defiened as:

```C++
float32 lx      // left joystick x, range [-1.0 ~ 1.0]
float32 ly      // left joystick y, range [-1.0 ~ 1.0]
float32 rx      // right joystick x, range [-1.0 ~ 1.0]
float32 ry      // right joystick y, range [-1.0 ~ 1.0]
uint16  keys    // pressed keys
```

For more details, see https://support.unitree.com/home/en/developer/Get_remote_control_status

To run a complete example:

```bash
./install/unitree_ros2_example/bin/read_wireless_controller
```

## Robot control

### 1. Sportmode 

Sportmode control can be achieved by sending a `unitree_api::msg::Request`
message to the `/api/sport/request` topic.

The Request message can be generated by the SportClient class in 
`/example/src/common/ros2_sport_client.cpp`. For example:

```C++
// Create a ros2 publisher
rclcpp::Publisher<unitree_api::msg::Request>::SharedPtr req_puber = this->create_publisher<unitree_api::msg::Request>("/api/sport/request", 10);

SportClient sport_req;                  // Sportclient object
unitree_api::msg::Request req;          // Sportmode request msg
sport_req.Euler(req, r, p, y);          // Sportmode request msg from Sportclient

req_puber->publish(req);                // Publish request msg
```

For details on SportClient, see https://support.unitree.com/home/en/developer/sports_services

To run a complete example:

```bash
./install/unitree_ros2_example/bin/sport_mode_ctrl
```

Ater 1 second, the robot will walk back and forth in the x direction.

### 2. Motor control

The torque, position and velocity control of each motor can be controlled by
subscribing "/lowcmd" topic and sending `unitree_go::msg::LowCmd` messages. 

The .msg file is defined as:

```C++
uint8[2]        head
uint8           level_flag
uint8           frame_reserve
uint32[2]       sn
uint32[2]       version
uint16          bandwidth
MotorCmd[20]    motor_cmd           // motor command
BmsCmd          bms_cmd
uint8[40]       wireless_remote
uint8[12]       led
uint8[2]        fan
uint8           gpio
uint32          reserve
uint32          crc
```

where the MotorCmd struct is defined as:

```C++
uint8 mode;     // mode (foc mode -> 0x01，stop mode -> 0x00)
float q;        // target position (rad)
float dq;       // target velocity (rad/s)
float tau;      // target torque (N.M)
float kp;       // motor's PD controller's kp 
float kd;       // motor's PD controller's kd
unsigned long   reserve[3]; 
```

For more details, see https://support.unitree.com/home/en/developer/Basic_services

To run a complete example:

```bash
./install/unitree_ros2_example/bin/sport_mode_ctrl
```

The hip and calf motors of the RL leg will rotate to the corresponding joint
angle.

## Rviz

We can also use rviz to visualize the Unitree robot data.

First, list all topics with

```bash
ros2 topic list
```

so we can verify that the integrated lidar point cloud information is published
on the

```bash
utlidar/cloud
```

topic. Then, print its `frame_id`

```
ros2 topic echo --no-arr /utlidar/cloud
```

and you should get `utlidar_lidar`.

Finally, run rviz：

```
ros2 run rviz2 rviz2
```

and add the `/utlidar/cloud` in rviz2 and modify the `Fixed frame` to
`utlidar_lidar`.
